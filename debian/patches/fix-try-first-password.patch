## Implement the intended semantics of try_first_password as described in
## in the manual page (and PAM).  Look for SSH keys in 
## $HOME/.ssh/login-keys.d/.  Ask for SSH passphrase even if user does not
## exist.

## This code was put into the public domain by Jens Peter Secher <jps@debian.org>.

## 2012/08/23: upgraded and slightly improved by Jerome Benoit <calculus@rezozer.net>

--- a/pam_ssh.c
+++ b/pam_ssh.c
@@ -58,7 +58,9 @@
 #endif
 
 #include <errno.h>
+#include <dirent.h>
 #include <fcntl.h>
+#include <fnmatch.h>
 #include <pwd.h>
 #include <signal.h>
 #include <stdio.h>
@@ -85,6 +87,7 @@
 #include <openssl/dsa.h>
 #include <openssl/evp.h>
 
+#include "log.h"
 #include "key.h"
 #include "authfd.h"
 #include "authfile.h"
@@ -106,31 +109,26 @@
 # define __unused
 #endif
 
-#define	MODULE_NAME			PACKAGE_NAME
-#define	NEED_PASSPHRASE			"SSH passphrase: "
-#define DEF_KEYFILES			"id_dsa,id_rsa,identity"
-#define ENV_PID_SUFFIX			"_AGENT_PID"
-#define ENV_SOCKET_SUFFIX		"_AUTH_SOCK"
-#define PAM_OPT_KEYFILES_NAME		"keyfiles"
+#define	MODULE_NAME "pam_ssh"
+#define	NEED_PASSPHRASE "SSH passphrase: "
+#define ENV_PID_SUFFIX "_AGENT_PID"
+#define ENV_SOCKET_SUFFIX "_AUTH_SOCK"
 #define PAM_OPT_BLANK_PASSPHRASE_NAME	"allow_blank_passphrase"
-#define PAM_OPT_NULLOK_NAME             "nullok"
-#define SEP_KEYFILES			","
-#define SSH_CLIENT_DIR			".ssh"
+#define PAM_OPT_NULLOK_NAME "nullok"
+#define SSH_DIR ".ssh"
+#define SSH_LOGIN_KEYS_DIR "login-keys.d"
 
 enum {
 #if HAVE_OPENPAM || HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
-	PAM_OPT_KEYFILES = PAM_OPT_STD_MAX,
-	PAM_OPT_BLANK_PASSPHRASE,
+	PAM_OPT_BLANK_PASSPHRASE = PAM_OPT_STD_MAX,
 	PAM_OPT_NULLOK
 #else
-	PAM_OPT_KEYFILES,
 	PAM_OPT_BLANK_PASSPHRASE,
 	PAM_OPT_NULLOK
 #endif
 };
 
 static struct opttab other_options[] = {
-	{ PAM_OPT_KEYFILES_NAME,		PAM_OPT_KEYFILES },
 	{ PAM_OPT_BLANK_PASSPHRASE_NAME,	PAM_OPT_BLANK_PASSPHRASE },
 	{ PAM_OPT_NULLOK_NAME,	                PAM_OPT_NULLOK },
 	{ NULL, 0 }
@@ -214,35 +212,26 @@
  */
 
 static int
-auth_via_key(pam_handle_t *pamh, const char *file, const char *dir,
-    const struct passwd *user, const char *pass, int allow_blank)
+auth_via_key(pam_handle_t *pamh, const char *path, const char *name,
+             const char *pass, int allow_blank)
 {
 	char *comment;		/* private key comment */
 	char *data_name;	/* PAM state */
 	static int index = 0;	/* for saved keys */
 	Key *key;		/* user's key */
-	char *path;		/* to key files */
 	int retval;		/* from calls */
 
 	/* an int only goes so far */
 
 	if (index < 0)
 		return PAM_SERVICE_ERR;
-	  
-	/* locate the user's private key file */
-
-	if (asprintf(&path, "%s/%s", dir, file) == -1) {
-		pam_ssh_log(LOG_CRIT, "out of memory");
-		return PAM_SERVICE_ERR;
-	}
 
 	/* Try to decrypt the private key with the passphrase provided.  If
 	   success, the user is authenticated. */
 
 	comment = NULL;
 	key = key_load_private_maybe(path, pass, &comment, allow_blank);
-	free(path);
-	if (!comment && !(comment = strdup(file))) {
+	if (!comment && !(comment = strdup(name))) {
 		pam_ssh_log(LOG_CRIT, "out of memory");
 		return PAM_SERVICE_ERR;
 	}
@@ -511,23 +500,116 @@
 	return PAM_SUCCESS;
 }
 
+static int
+login_keys_selector(const struct dirent * candidate)
+{
+	if (candidate) {
+		mode_t mode=DTTOIF(candidate->d_type);
+		/* Discard non-regular/non-linked files. */
+		if ((S_ISREG(mode)) || (S_ISLNK(mode))) {
+			/* Ignore disabled/frozen files. */
+			const char * suffix=strchrnul(candidate->d_name,'.');
+			if (!((!(strcmp(".disabled",suffix))) || (!(strcmp(".frozen",suffix))))) {
+				pam_ssh_log(LOG_DEBUG/*2*/, "'%s' link or file is selected", candidate->d_name);
+				return 1;
+			}
+			else {
+				pam_ssh_log(LOG_DEBUG/*2*/, "'%s' link or file is ignored", candidate->d_name);
+				return 0;
+			}
+		}
+		else {
+			pam_ssh_log(LOG_DEBUG/*2*/, "'%s' is not a link or a regular file", candidate->d_name);
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
+static void
+unlock_standard_keys(pam_handle_t *pamh, const char *pass, const char *dotdir,
+                     int allow_blank)
+{
+	char *files[] = {"id_dsa", "id_rsa", "identity", NULL};
+	int i;
+	char *path;
+	if (0 == pass) {
+		pam_ssh_log(LOG_DEBUG, "No preceding password.");
+		return;
+	}
+	pam_ssh_log(LOG_DEBUG, "Looking for SSH keys in '%s'.",dotdir);
+	for (i = 0; files[i]; ++i) {
+		pam_ssh_log(LOG_DEBUG/*2*/, "SSH key candidate '%s'.", files[i]);
+		/* Locate the user's private key file. */
+		if (asprintf(&path, "%s/%s", dotdir, files[i]) == -1) {
+			pam_ssh_log(LOG_CRIT, "out of memory");
+			return;
+		}
+		if (PAM_SUCCESS == auth_via_key(pamh, path, files[i], pass, allow_blank)) {
+			pam_ssh_log(LOG_DEBUG, "SSH key '%s' decrypted.", files[i]);
+		} else {
+			pam_ssh_log(LOG_DEBUG, "SSH key candidate '%s' failed.", files[i]);
+		}
+		free(path);
+	}
+}
+
+
+static int
+unlock_at_least_one_key(pam_handle_t *pamh, const char *pass, const char *dotdir,
+                        struct dirent **namelist, int n, int allow_blank)
+{
+	const char * file;
+	char *path;
+	int result = PAM_AUTH_ERR;
+	if (0 == pass) {
+		pam_ssh_log(LOG_DEBUG, "No preceding password.");
+		return PAM_AUTH_ERR;
+	}
+	pam_ssh_log(LOG_DEBUG, "Looking for SSH keys in '%s'.",dotdir);
+	/* Any key will authenticate us, but if we can decrypt all of the
+	   specified keys, we will do so here so we can cache them in the
+	   session phase. */
+	while (n--) {
+		file = namelist[n]->d_name;
+		pam_ssh_log(LOG_DEBUG/*2*/, "SSH login key candidate '%s'.", file);
+		/* Locate the user's private key file. */
+		if (asprintf(&path, "%s/%s", dotdir, file) == -1) {
+			pam_ssh_log(LOG_CRIT, "out of memory");
+			return PAM_SERVICE_ERR;
+		}
+		if (PAM_SUCCESS == auth_via_key(pamh, path, file, pass, allow_blank)) {
+			pam_ssh_log(LOG_DEBUG, "SSH key '%s' decrypted.", file);
+			result = PAM_SUCCESS;
+		} else {
+			pam_ssh_log(LOG_DEBUG, "SSH key candidate '%s' failed.", file);
+		}
+		free(path);
+	}
+	return result;
+}
+
+#define CLEANUP_AND_RETURN(retcode) \
+	while (n--) free(namelist[n]); \
+	free(namelist); \
+	free(dotdir); \
+	free(logindir); \
+	openpam_restore_cred(pamh); \
+	return retcode
 
 PAM_EXTERN int
 pam_sm_authenticate(pam_handle_t *pamh, int flags __unused, int argc,
     const char **argv)
 {
 	int allow_blank_passphrase = 0;	/* allow blank passphrases? */
-	int authenticated;		/* user authenticated? */
 	char *dotdir;			/* .ssh dir name */
-	char *file;			/* current key file */
-	char *keyfiles;			/* list of key files to add */
-#if HAVE_OPENPAM
-	const char *kfspec;		/* list of key files to add */
-#elif HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
-	char *kfspec;			/* list of key files to add */
+	char *logindir;			/* login-key dir name */
+	int n;                          /* count of ssh keys */
+	struct dirent **namelist;       /* ssh keys */
+#if HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
 	struct options options;		/* options for pam_get_pass() */
 #else
-	char *kfspec;			/* list of key files to add */
 	int options;			/* options for pam_get_pass() */
 #endif
 	const char *pass;		/* passphrase */
@@ -535,31 +617,27 @@
 	int retval;			/* from calls */
 	const char *user;		/* username */
 
-	keyfiles = kfspec = NULL;
+	dotdir = logindir = NULL;
 #if HAVE_OPENPAM
-	if ((kfspec = openpam_get_option(pamh, PAM_OPT_KEYFILES_NAME))) {
-		if (!(kfspec = opt_arg(kfspec))) {
-			openpam_log(PAM_LOG_ERROR, "invalid keyfile list");
-			return PAM_SERVICE_ERR;
-		}
-	} else
-		kfspec = DEF_KEYFILES;
-	if ((kfspec = openpam_get_option(pamh, PAM_OPT_BLANK_PASSPHRASE))
-          || kfspec = openpam_get_option(pamh, PAM_OPT_NULLOK))
+	log_init(MODULE_NAME, SYSLOG_LEVEL_ERROR, SYSLOG_FACILITY_AUTHPRIV, 0);
+	if ((openpam_get_option(pamh, PAM_OPT_BLANK_PASSPHRASE))
+			|| (openpam_get_option(pamh, PAM_OPT_NULLOK)))
 		allow_blank_passphrase = 1;
 #elif HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
 	memset(&options, 0, sizeof options);
 	pam_std_option(&options, other_options, argc, argv);
-        log_debug = pam_test_option(&options, PAM_OPT_DEBUG, NULL);
-        pam_ssh_log(LOG_DEBUG, "init authentication module");
-	if (!pam_test_option(&options, PAM_OPT_KEYFILES, &kfspec))
-		kfspec = DEF_KEYFILES;
+	if ((log_debug = pam_test_option(&options, PAM_OPT_DEBUG, NULL)))
+		log_init(MODULE_NAME, SYSLOG_LEVEL_DEBUG3, SYSLOG_FACILITY_AUTHPRIV, 0);
+	else
+		log_init(MODULE_NAME, SYSLOG_LEVEL_ERROR, SYSLOG_FACILITY_AUTHPRIV, 0);
+	pam_ssh_log(LOG_DEBUG, "init authentication module");
 	allow_blank_passphrase =
 		pam_test_option(&options, PAM_OPT_BLANK_PASSPHRASE, NULL);
-        if(!allow_blank_passphrase)
-                allow_blank_passphrase =
-                   pam_test_option(&options, PAM_OPT_NULLOK, NULL);
+	if(!allow_blank_passphrase)
+		allow_blank_passphrase =
+			pam_test_option(&options, PAM_OPT_NULLOK, NULL);
 #else
+	log_init(MODULE_NAME, SYSLOG_LEVEL_ERROR, SYSLOG_FACILITY_AUTHPRIV, 0);
 	options = 0;
 	for (; argc; argc--, argv++) {
 		struct opttab *p;
@@ -568,101 +646,137 @@
 			if (strcmp(*argv, p->name) != 0)
 				continue;
 			switch (p->value) {
-			PAM_OPT_KEYFILES:
-				if (!(kfspec = opt_arg(*argv))) {
-					pam_ssh_log(LOG_ERR,
-					    "invalid keyfile list");
-					return PAM_SERVICE_ERR;
-				}
-				break;
-			PAM_OPT_BLANK_PASSPHRASE:
-                        PAM_OPT_NULLOK:
-				allow_blank_passphrase = 1;
-				break;
+				PAM_OPT_BLANK_PASSPHRASE:
+      	PAM_OPT_NULLOK:
+					allow_blank_passphrase = 1;
+					break;
 			}
 		}
 		pam_std_option(&options, *argv);
 	}
-	if (!kfspec)
-		kfspec = DEF_KEYFILES;
 #endif
 
 	if ((retval = pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS) {
-            pam_ssh_log(LOG_ERR, "can't get username (ret=%d)", retval);
-            return retval;
-        }
-        
-        if (!(user && (pwent = getpwnam(user)))) {
-            pam_ssh_log(LOG_ERR, "user not known");
-            return PAM_AUTH_ERR;
-        }
+		pam_ssh_log(LOG_ERR, "can't get username (ret=%d)", retval);
+		return retval;
+	}
         
+	if (!(user && (pwent = getpwnam(user)))) {
+		pam_ssh_log(LOG_ERR, "user not known");
+		if (! pam_test_option(&options, PAM_OPT_USE_FIRST_PASS, NULL)) {
+			/* Asking for passphrase anyway to not leak information. */
+			pam_conv_pass(pamh, NEED_PASSPHRASE, &options);
+		}
+		openpam_restore_cred(pamh);
+		return PAM_AUTH_ERR;
+	}
+
 	if (!(pwent->pw_dir && *pwent->pw_dir)) {
-            pam_ssh_log(LOG_ERR, "cannot get homedirectory");
-            return PAM_AUTH_ERR;
-        }
+		pam_ssh_log(LOG_ERR, "cannot get home directory");
+		if (! pam_test_option(&options, PAM_OPT_USE_FIRST_PASS, NULL)) {
+			/* Asking for passphrase anyway to not leak information. */
+			pam_conv_pass(pamh, NEED_PASSPHRASE, &options);
+		}
+		openpam_restore_cred(pamh);
+		return PAM_AUTH_ERR;
+	}
 
 	retval = openpam_borrow_cred(pamh, pwent);
 	if (retval != PAM_SUCCESS && retval != PAM_PERM_DENIED) {
-	    pam_ssh_log(LOG_ERR, "can't drop privileges: %m");
-	    return retval;
+		pam_ssh_log(LOG_ERR, "can't drop privileges: %m");
+		return retval;
 	}
 
-	/* pass prompt message to application and receive passphrase */
+	/* Locate SSH directory. */
+	if (asprintf(&dotdir, "%s/%s", pwent->pw_dir, SSH_DIR) == -1) {
+		pam_ssh_log(LOG_CRIT, "out of memory");
+		openpam_restore_cred(pamh);
+		return PAM_SERVICE_ERR;
+	}
 
-#if HAVE_OPENPAM
-	retval = pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NEED_PASSPHRASE);
-#elif HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
-	retval = pam_get_pass(pamh, &pass, NEED_PASSPHRASE, &options);
-#else
-	retval = pam_get_pass(pamh, &pass, NEED_PASSPHRASE, options);
-#endif
-	if (retval != PAM_SUCCESS) {
-            pam_ssh_log(LOG_ERR, "can't get passphrase from PAM");
-            openpam_restore_cred(pamh);
-	    return retval;
+	/* Locate SSH login-keys directory. */
+	if (asprintf(&logindir, "%s/%s", dotdir, SSH_LOGIN_KEYS_DIR) == -1) {
+		pam_ssh_log(LOG_CRIT, "out of memory");
+		openpam_restore_cred(pamh);
+		return PAM_SERVICE_ERR;
 	}
 
-	if (!pass) {
-            pam_ssh_log(LOG_ERR, "blank passphrases disabled");
-	    openpam_restore_cred(pamh);
-	    return PAM_AUTH_ERR;
+	namelist = NULL;
+	n = scandir(logindir, &namelist, &login_keys_selector, alphasort);
+	if (-1 == n) {
+		if (ENOMEM == errno) {
+			pam_ssh_log(LOG_CRIT, "out of memory");
+			openpam_restore_cred(pamh);
+			return PAM_SERVICE_ERR;
+		}
+		else {
+			pam_ssh_log(LOG_DEBUG, "No SSH login-keys directory.");
+			n = 0;
+		}
 	}
 
 	OpenSSL_add_all_algorithms(); /* required for DSA */
 
-	/* any key will authenticate us, but if we can decrypt all of the
-           specified keys, we'll do so here so we can cache them in the
-           session phase */
-
-	if (asprintf(&dotdir, "%s/%s", pwent->pw_dir, SSH_CLIENT_DIR) == -1) {
-		pam_ssh_log(LOG_CRIT, "out of memory");
-		openpam_restore_cred(pamh);
-		return PAM_SERVICE_ERR;
+	/* Grab an already-entered password from a previous module if the user
+		 wants to use it for the SSH keys. */
+	if ((pam_test_option(&options, PAM_OPT_TRY_FIRST_PASS, NULL))
+		|| (pam_test_option(&options, PAM_OPT_USE_FIRST_PASS, NULL))) {
+		pam_ssh_log(LOG_DEBUG, "Grabbing password from preceding auth module.");
+		retval = pam_get_item(pamh, PAM_AUTHTOK, (const void **)&pass);
+		if (retval != PAM_SUCCESS) {
+			pam_ssh_log(LOG_DEBUG, "Could not grab password from preceding auth module.");
+			CLEANUP_AND_RETURN(retval);
+		}
 	}
-	authenticated = 0;
-	if (!(keyfiles = strdup(kfspec))) {
-		pam_ssh_log(LOG_CRIT, "out of memory");
-		openpam_restore_cred(pamh);
-		return PAM_SERVICE_ERR;
+
+	/* If use_first_password option given, then go through all keys and
+	   unlock each that matches.  If none matches, fail, otherwise succeed. */
+	if (pam_test_option(&options, PAM_OPT_USE_FIRST_PASS, NULL)) {
+		pam_ssh_log(LOG_DEBUG, "Using previous password for SSH keys.");
+		/* Unlock any of the standard SSH keys with the password from the previous PAM module. */
+		unlock_standard_keys(pamh,pass,dotdir,allow_blank_passphrase);
+		/* Fail if there are no SSH login keys. */
+		if (0 == n) {
+			CLEANUP_AND_RETURN(PAM_AUTH_ERR);
+			}
+		retval = unlock_at_least_one_key(pamh,pass,logindir,namelist,n,allow_blank_passphrase);
+		CLEANUP_AND_RETURN(retval);
 	}
-	for (file = strtok(keyfiles, SEP_KEYFILES); file;
-	     file = strtok(NULL, SEP_KEYFILES))
-		if (auth_via_key(pamh, file, dotdir, pwent, pass,
-                    allow_blank_passphrase) == PAM_SUCCESS) {
-                    pam_ssh_log(LOG_DEBUG, "auth successful for key %s", file);
-		    authenticated = 1;
-                }
-	free(dotdir);
-	free(keyfiles);
-	if (!authenticated) {
-            pam_ssh_log(LOG_DEBUG, "not able to open any key");
-	    openpam_restore_cred(pamh);
-	    return PAM_AUTH_ERR;
+
+	/* If try_first_password option given, then go through all keys and
+	   unlock each that matches. If any matches, then succeed. */
+	if (pam_test_option(&options, PAM_OPT_TRY_FIRST_PASS, NULL)) {
+		pam_ssh_log(LOG_DEBUG, "Trying previous password for SSH keys.");
+		/* Unlock any of the standard SSH keys with the password from the previous PAM module. */
+		unlock_standard_keys(pamh,pass,dotdir,allow_blank_passphrase);
+		/* Fail if there are no SSH login keys. */
+		if (0 == n) {
+			CLEANUP_AND_RETURN(PAM_AUTH_ERR);
+		}
+		retval = unlock_at_least_one_key(pamh,pass,logindir,namelist,n,allow_blank_passphrase);
+		if (PAM_SUCCESS == retval) {
+			CLEANUP_AND_RETURN(PAM_SUCCESS);
+		}
 	}
 
-	openpam_restore_cred(pamh);
-	return PAM_SUCCESS;
+	/* Either no option was given, or try_first_password was given but could not
+		 use the previous password, so we need to get a specific SSH key passphrase. */
+	pam_ssh_log(LOG_DEBUG, "Asking for SSH key passphrase.");
+	retval = pam_conv_pass(pamh, NEED_PASSPHRASE, &options);
+	if (retval != PAM_SUCCESS) {
+		pam_ssh_log(LOG_DEBUG, "Could not get SSH key passphrase.");
+		CLEANUP_AND_RETURN(retval);
+	}
+	retval = pam_get_item(pamh, PAM_AUTHTOK, (const void **)&pass);
+	if (retval != PAM_SUCCESS) {
+		pam_ssh_log(LOG_DEBUG, "Could not obtain passphrase.");
+		CLEANUP_AND_RETURN(retval);
+	}
+	/* Unlock any of the standard SSH keys with the password. */
+	unlock_standard_keys(pamh,pass,dotdir,allow_blank_passphrase);
+	/* Unlock login keys with the password. */
+	retval = unlock_at_least_one_key(pamh,pass,logindir,namelist,n,allow_blank_passphrase);
+	CLEANUP_AND_RETURN(retval);
 }
 
 
@@ -696,10 +810,17 @@
 	const char *user;               /* username */
 	struct options options;         /* PAM options */
 
+#if HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
 	memset(&options, 0, sizeof options);
 	pam_std_option(&options, other_options, argc, argv);
-	log_debug = pam_test_option(&options, PAM_OPT_DEBUG, NULL);
+	if ((log_debug = pam_test_option(&options, PAM_OPT_DEBUG, NULL)))
+		log_init(MODULE_NAME, SYSLOG_LEVEL_DEBUG3, SYSLOG_FACILITY_AUTHPRIV, 0);
+	else
+		log_init(MODULE_NAME, SYSLOG_LEVEL_ERROR, SYSLOG_FACILITY_AUTHPRIV, 0);
 	pam_ssh_log(LOG_DEBUG, "open session");
+#else
+	log_init(MODULE_NAME, SYSLOG_LEVEL_ERROR, SYSLOG_FACILITY_AUTHPRIV, 0);
+#endif
 
 	if ((retval = pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS) {
 		pam_ssh_log(LOG_ERR, "can't get username (ret=%d)", retval);
@@ -814,6 +935,7 @@
 	ssh_close_authentication_connection(ac);
 
 	if (start_agent && retval != PAM_SUCCESS) {
+		pam_ssh_log(LOG_DEBUG, "could not start SSH agent");
 		openpam_restore_cred(pamh);
 		return retval;
 	}
--- a/pam_get_pass.h
+++ b/pam_get_pass.h
@@ -28,4 +28,5 @@
 
 __BEGIN_DECLS
 int	pam_get_pass(pam_handle_t *, const char **, const char *, struct options *);
+int pam_conv_pass(pam_handle_t *, const char *, struct options *);
 __END_DECLS
--- a/pam_get_pass.c
+++ b/pam_get_pass.c
@@ -40,9 +40,7 @@
 #endif
 #include "pam_get_pass.h"
 
-static int	 pam_conv_pass(pam_handle_t *, const char *, struct options *);
-
-static int
+int
 pam_conv_pass(pam_handle_t *pamh, const char *prompt, struct options *options)
 {
 	const struct pam_conv *conv;
