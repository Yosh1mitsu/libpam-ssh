## Implement the intended semantics of try_first_password as described in
## in the manual page (and PAM).  Look for SSH keys in 
## $HOME/.ssh/login-keys.d/.  Ask for SSH passphrase even if user does not
## exist.

## This code was put into the public domain by Jens Peter Secher <jps@debian.org>.

Index: libpam-ssh/pam_get_pass.c
===================================================================
--- libpam-ssh.orig/pam_get_pass.c	2009-04-04 10:59:20.000000000 +0200
+++ libpam-ssh/pam_get_pass.c	2009-04-04 11:00:20.000000000 +0200
@@ -40,9 +40,7 @@
 #endif
 #include "pam_get_pass.h"
 
-static int	 pam_conv_pass(pam_handle_t *, const char *, struct options *);
-
-static int
+int
 pam_conv_pass(pam_handle_t *pamh, const char *prompt, struct options *options)
 {
 	const struct pam_conv *conv;
Index: libpam-ssh/pam_get_pass.h
===================================================================
--- libpam-ssh.orig/pam_get_pass.h	2009-04-04 10:59:20.000000000 +0200
+++ libpam-ssh/pam_get_pass.h	2009-04-04 11:00:20.000000000 +0200
@@ -28,4 +28,5 @@
 
 __BEGIN_DECLS
 int	pam_get_pass(pam_handle_t *, const char **, const char *, struct options *);
+int pam_conv_pass(pam_handle_t *, const char *, struct options *);
 __END_DECLS
Index: libpam-ssh/pam_ssh.c
===================================================================
--- libpam-ssh.orig/pam_ssh.c	2009-04-04 11:00:20.000000000 +0200
+++ libpam-ssh/pam_ssh.c	2009-04-04 11:02:07.000000000 +0200
@@ -55,7 +55,9 @@
 #endif
 
 #include <errno.h>
+#include <dirent.h>
 #include <fcntl.h>
+#include <fnmatch.h>
 #include <pwd.h>
 #include <signal.h>
 #include <stdio.h>
@@ -103,26 +105,18 @@
 
 #define	MODULE_NAME			"pam_ssh"
 #define	NEED_PASSPHRASE			"SSH passphrase: "
-#define DEF_KEYFILES			"id_dsa,id_rsa,identity"
 #define ENV_PID_SUFFIX			"_AGENT_PID"
 #define ENV_SOCKET_SUFFIX		"_AUTH_SOCK"
-#define PAM_OPT_KEYFILES_NAME		"keyfiles"
 #define PAM_OPT_BLANK_PASSPHRASE_NAME	"allow_blank_passphrase"
-#define SEP_KEYFILES			","
-#define SSH_CLIENT_DIR			".ssh"
+#define SSH_DIR				".ssh"
+#define SSH_LOGIN_KEYS_DIR		"login-keys.d"
 
 enum {
-#if HAVE_OPENPAM || HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
-	PAM_OPT_KEYFILES = PAM_OPT_STD_MAX,
-	PAM_OPT_BLANK_PASSPHRASE
-#else
-	PAM_OPT_KEYFILES,
-	PAM_OPT_BLANK_PASSPHRASE
-#endif
+	/* The first option after the standard options. */
+	PAM_OPT_BLANK_PASSPHRASE = 8
 };
 
 static struct opttab other_options[] = {
-	{ PAM_OPT_KEYFILES_NAME,		PAM_OPT_KEYFILES },
 	{ PAM_OPT_BLANK_PASSPHRASE_NAME,	PAM_OPT_BLANK_PASSPHRASE },
 	{ NULL, 0 }
 };
@@ -204,7 +198,7 @@
 
 static Key *
 key_load_private_maybe(const char *path, const char *passphrase,
-    char **commentp, int allow_blank)
+                       char **commentp, int allow_blank)
 {
 	Key *key;
 
@@ -226,14 +220,13 @@
  */
 
 static int
-auth_via_key(pam_handle_t *pamh, const char *file, const char *dir,
-    const struct passwd *user, const char *pass, int allow_blank)
+auth_via_key(pam_handle_t *pamh, const char *path, const char *name,
+             const char *pass, int allow_blank)
 {
 	char *comment;		/* private key comment */
 	char *data_name;	/* PAM state */
 	static int index = 0;	/* for saved keys */
 	Key *key;		/* user's key */
-	char *path;		/* to key files */
 	int retval;		/* from calls */
 
 	/* an int only goes so far */
@@ -241,20 +234,12 @@
 	if (index < 0)
 		return PAM_SERVICE_ERR;
 	  
-	/* locate the user's private key file */
-
-	if (asprintf(&path, "%s/%s", dir, file) == -1) {
-		pam_ssh_log(LOG_CRIT, "out of memory");
-		return PAM_SERVICE_ERR;
-	}
-
 	/* Try to decrypt the private key with the passphrase provided.  If
 	   success, the user is authenticated. */
 
 	comment = NULL;
 	key = key_load_private_maybe(path, pass, &comment, allow_blank);
-	free(path);
-	if (!comment && !(comment = strdup(file))) {
+	if (!comment && !(comment = strdup(name))) {
 		pam_ssh_log(LOG_CRIT, "out of memory");
 		return PAM_SERVICE_ERR;
 	}
@@ -511,58 +496,126 @@
 }
 
 
+static void
+unlock_standard_keys(pam_handle_t *pamh, const char *pass, const char *dotdir,
+                     int allow_blank)
+{
+	char *files[] = {"id_dsa", "id_rsa", "identity", NULL};
+	int i;
+	char *path;
+	if (0 == pass) {
+		debug("No preceding password.");
+		return;
+	}
+	debug("Looking for SSH keys in '%s'.",dotdir);
+	for (i = 0; files[i]; ++i) {
+		debug2("SSH key candidate '%s'.", files[i]);
+		/* Locate the user's private key file. */
+		if (asprintf(&path, "%s/%s", dotdir, files[i]) == -1) {
+			pam_ssh_log(LOG_CRIT, "out of memory");
+			return;
+		}
+		if (PAM_SUCCESS == auth_via_key(pamh, path, files[i], pass,
+		                                allow_blank)) {
+			debug("SSH key '%s' decrypted.", files[i]);
+		} else {
+			debug2("SSH key candidate '%s' failed.", files[i]);
+		}
+		free(path);
+	}
+}
+
+
+static int
+unlock_at_least_one_key(pam_handle_t *pamh, const char *pass, const char *dotdir,
+                        struct dirent **namelist, int n, int allow_blank)
+{
+	struct stat buf;
+	const char * file;
+	char *path;
+	int result = PAM_AUTH_ERR;
+	if (0 == pass) {
+		debug("No preceding password.");
+		return PAM_AUTH_ERR;
+	}
+	debug("Looking for SSH keys in '%s'.",dotdir);
+	/* Any key will authenticate us, but if we can decrypt all of the
+	   specified keys, we will do so here so we can cache them in the
+	   session phase. */
+	while (n--) {
+		file = namelist[n]->d_name;
+		debug2("SSH login key candidate '%s'.", file);
+		/* Locate the user's private key file. */
+		if (asprintf(&path, "%s/%s", dotdir, file) == -1) {
+			pam_ssh_log(LOG_CRIT, "out of memory");
+			return PAM_SERVICE_ERR;
+		}
+		/* Discard non-regular/non-linked files. */
+		if (stat(path, &buf) == -1) {
+			debug("Could not stat '%s'", file);
+		} else if (!S_ISREG(buf.st_mode) && !S_ISLNK(buf.st_mode) ) {
+			debug2("'%s' is not a link or a regular file", file);
+		} else if (PAM_SUCCESS == auth_via_key(pamh, path, file, pass,
+		                                       allow_blank)) {
+			debug("SSH key '%s' decrypted.", file);
+			result = PAM_SUCCESS;
+		} else {
+			debug("SSH key candidate '%s' failed.", file);
+		}
+		free(path);
+	}
+	return result;
+}
+
+
+#define CLEANUP_AND_RETURN(retcode) \
+	while (n--) free(namelist[n]); \
+	free(namelist); \
+	free(dotdir); \
+	free(logindir); \
+	openpam_restore_cred(pamh); \
+	return retcode
+
+
 PAM_EXTERN int
 pam_sm_authenticate(pam_handle_t *pamh, int flags __unused, int argc,
                     const char **argv)
 {
 	int allow_blank_passphrase;	/* allow blank passphrases? */
-	int authenticated;		/* user authenticated? */
 	char *dotdir;			/* .ssh dir name */
-	char *file;			/* current key file */
-	char *keyfiles;			/* list of key files to add */
-#if HAVE_OPENPAM
-	const char *kfspec;		/* list of key files to add */
-#elif HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
-	char *kfspec;			/* list of key files to add */
+	char *logindir;			/* login-key dir name */
+	int n;                          /* count of ssh keys */
+	struct dirent **namelist;       /* ssh keys */
+#	if HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
 	struct options options;		/* options for pam_get_pass() */
-#else
-	char *kfspec;			/* list of key files to add */
+#	else
 	int options;			/* options for pam_get_pass() */
-#endif
+#	endif
 	const char *pass;		/* passphrase */
 	const struct passwd *pwent;	/* user's passwd entry */
 	int retval;			/* from calls */
 	const char *user;		/* username */
 
+	dotdir = logindir = NULL;
 	allow_blank_passphrase = 0;
-	keyfiles = kfspec = NULL;
-#if HAVE_OPENPAM
+#	if HAVE_OPENPAM
 	log_init(MODULE_NAME, SYSLOG_LEVEL_ERROR, SYSLOG_FACILITY_AUTHPRIV, 0);
-	if ((kfspec = openpam_get_option(pamh, PAM_OPT_KEYFILES_NAME))) {
-		if (!(kfspec = opt_arg(kfspec))) {
-			openpam_log(PAM_LOG_ERROR, "invalid keyfile list");
-			return PAM_SERVICE_ERR;
-		}
-	} else
-		kfspec = DEF_KEYFILES;
-	if ((kfspec = openpam_get_option(pamh, PAM_OPT_BLANK_PASSPHRASE)))
+	if (openpam_get_option(pamh, PAM_OPT_BLANK_PASSPHRASE))
 		allow_blank_passphrase = 1;
-#elif HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
+#	elif HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
 	memset(&options, 0, sizeof options);
 	pam_std_option(&options, other_options, argc, argv);
 	/* Set LOG level to DEBUG if 'debug' option is given to module. */
 	if (pam_test_option(&options, PAM_OPT_DEBUG, NULL)) {
-		log_init(MODULE_NAME, SYSLOG_LEVEL_DEBUG2,
+		log_init(MODULE_NAME, SYSLOG_LEVEL_DEBUG1,
 		         SYSLOG_FACILITY_AUTHPRIV, 0);
 		debug("Authentication debugging.");
 	} else
 		log_init(MODULE_NAME, SYSLOG_LEVEL_ERROR,
 		         SYSLOG_FACILITY_AUTHPRIV, 0);
-	if (!pam_test_option(&options, PAM_OPT_KEYFILES, &kfspec))
-		kfspec = DEF_KEYFILES;
 	allow_blank_passphrase =
 		pam_test_option(&options, PAM_OPT_BLANK_PASSPHRASE, NULL);
-#else
+#	else
 	log_init(MODULE_NAME, SYSLOG_LEVEL_ERROR, SYSLOG_FACILITY_AUTHPRIV, 0);
 	options = 0;
 	for (; argc; argc--, argv++) {
@@ -572,13 +625,6 @@
 			if (strcmp(*argv, p->name) != 0)
 				continue;
 			switch (p->value) {
-			PAM_OPT_KEYFILES:
-				if (!(kfspec = opt_arg(*argv))) {
-					pam_ssh_log(LOG_ERR,
-					            "invalid keyfile list");
-					return PAM_SERVICE_ERR;
-				}
-				break;
 			PAM_OPT_BLANK_PASSPHRASE:
 				allow_blank_passphrase = 1;
 				break;
@@ -586,15 +632,21 @@
 		}
 		pam_std_option(&options, *argv);
 	}
-	if (!kfspec)
-		kfspec = DEF_KEYFILES;
-#endif
+#	endif
 
 	if ((retval = pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS)
 		return retval;
 	if (!(user && (pwent = getpwnam(user)) && pwent->pw_dir &&
-	    *pwent->pw_dir))
+	    *pwent->pw_dir)) {
+		debug2("User unknown.");
+		if (! pam_test_option(&options, PAM_OPT_USE_FIRST_PASS, NULL)) {
+			/* Asking for passphrase anyway to not leak
+			   information. */
+			pam_conv_pass(pamh, NEED_PASSPHRASE, &options);
+		}
+		openpam_restore_cred(pamh);
 		return PAM_AUTH_ERR;
+	}
 
 	retval = openpam_borrow_cred(pamh, pwent);
 	if (retval != PAM_SUCCESS && retval != PAM_PERM_DENIED) {
@@ -602,55 +654,101 @@
 		return retval;
 	}
 
-	/* pass prompt message to application and receive passphrase */
-
-#if HAVE_OPENPAM
-	retval = pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NEED_PASSPHRASE);
-#elif HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
-	retval = pam_get_pass(pamh, &pass, NEED_PASSPHRASE, &options);
-#else
-	retval = pam_get_pass(pamh, &pass, NEED_PASSPHRASE, options);
-#endif
-	if (retval != PAM_SUCCESS) {
+	/* Locate SSH directory. */
+	if (asprintf(&dotdir, "%s/%s", pwent->pw_dir, SSH_DIR) == -1) {
+		pam_ssh_log(LOG_CRIT, "out of memory");
 		openpam_restore_cred(pamh);
-		return retval;
+		return PAM_SERVICE_ERR;
 	}
-	if (!pass) {
+	/* Locate SSH login-keys directory. */
+	if (asprintf(&logindir, "%s/%s", dotdir, SSH_LOGIN_KEYS_DIR) == -1) {
+		pam_ssh_log(LOG_CRIT, "out of memory");
 		openpam_restore_cred(pamh);
-		return PAM_AUTH_ERR;
+		return PAM_SERVICE_ERR;
+	}
+	namelist = NULL;
+	n = scandir(logindir, &namelist, NULL, alphasort);
+	if (-1 == n) {
+		if (ENOMEM == errno) {
+			pam_ssh_log(LOG_CRIT, "out of memory");
+			openpam_restore_cred(pamh);
+			return PAM_SERVICE_ERR;
+		} else {
+			debug("No SSH login-keys directory.");
+			n = 0;
+		}
 	}
 
 	OpenSSL_add_all_algorithms(); /* required for DSA */
 
-	/* any key will authenticate us, but if we can decrypt all of the
-	   specified keys, we'll do so here so we can cache them in the
-	   session phase */
+	/* Grab an already-entered password from a previous module if the user
+	   wants to use it for the SSH keys. */
+	if (pam_test_option(&options, PAM_OPT_TRY_FIRST_PASS, NULL) ||
+	    pam_test_option(&options, PAM_OPT_USE_FIRST_PASS, NULL)) {
+		debug("Grabbing password from preceding auth module.");
+		retval = pam_get_item(pamh, PAM_AUTHTOK, (void**)&pass);
+		if (retval != PAM_SUCCESS) {
+			debug("Could not grab password from preceding auth "
+			      "module.");
+			CLEANUP_AND_RETURN(retval);
+		}
+	}
 
-	if (asprintf(&dotdir, "%s/%s", pwent->pw_dir, SSH_CLIENT_DIR) == -1) {
-		pam_ssh_log(LOG_CRIT, "out of memory");
-		openpam_restore_cred(pamh);
-		return PAM_SERVICE_ERR;
+	/* If use_first_password option given, then go through all keys and
+	   unlock each that matches.  If none matches, fail, otherwise
+	   succeed. */
+	if (pam_test_option(&options, PAM_OPT_USE_FIRST_PASS, NULL)) {
+		debug("Using previous password for SSH keys.");
+		/* Unlock any of the standard SSH keys with the password from the
+		   previous PAM module. */
+		unlock_standard_keys(pamh,pass,dotdir,allow_blank_passphrase);
+		/* Fail if there are no SSH login keys. */
+		if (0 == n) {
+			CLEANUP_AND_RETURN(PAM_AUTH_ERR);
+		}
+		retval = unlock_at_least_one_key(pamh,pass,logindir,namelist,n,
+		                                 allow_blank_passphrase);
+		CLEANUP_AND_RETURN(retval);
+	}
+
+	/* If try_first_password option given, then go through all keys and
+	   unlock each that matches.  If any matches, then succeed. */
+	if (pam_test_option(&options, PAM_OPT_TRY_FIRST_PASS, NULL)) {
+		debug("Trying previous password for SSH keys.");
+		/* Unlock any of the standard SSH keys with the password from the
+		   previous PAM module. */
+		unlock_standard_keys(pamh,pass,dotdir,allow_blank_passphrase);
+		/* Fail if there are no SSH login keys. */
+		if (0 == n) {
+			CLEANUP_AND_RETURN(PAM_AUTH_ERR);
+		}
+		retval = unlock_at_least_one_key(pamh,pass,logindir,namelist,n,
+		                                 allow_blank_passphrase);
+		if (PAM_SUCCESS == retval) {
+			CLEANUP_AND_RETURN(PAM_SUCCESS);
+		}
 	}
-	authenticated = 0;
-	if (!(keyfiles = strdup(kfspec))) {
-		pam_ssh_log(LOG_CRIT, "out of memory");
-		openpam_restore_cred(pamh);
-		return PAM_SERVICE_ERR;
+
+	/* Either no option was given, or try_first_password was given but could
+	   not use the previous password, so we need to get a specific SSH key
+	   passphrase. */
+	debug("Asking for SSH key passphrase.");
+	retval = pam_conv_pass(pamh, NEED_PASSPHRASE, &options);
+	if (retval != PAM_SUCCESS) {
+		debug("Could not get SSH key passphrase.");
+		CLEANUP_AND_RETURN(retval);
 	}
-	for (file = strtok(keyfiles, SEP_KEYFILES); file;
-	     file = strtok(NULL, SEP_KEYFILES))
-		if (auth_via_key(pamh, file, dotdir, pwent, pass,
-		    allow_blank_passphrase) == PAM_SUCCESS)
-			authenticated = 1;
-	free(dotdir);
-	free(keyfiles);
-	if (!authenticated) {
-		openpam_restore_cred(pamh);
-		return PAM_AUTH_ERR;
+	retval = pam_get_item(pamh, PAM_AUTHTOK, (void**)&pass);
+	if (retval != PAM_SUCCESS) {
+		debug("Could not obtain passphrase.");
+		CLEANUP_AND_RETURN(retval);
 	}
-
-	openpam_restore_cred(pamh);
-	return PAM_SUCCESS;
+	/* Unlock any of the standard SSH keys with the password. */
+	unlock_standard_keys(pamh,pass,dotdir,allow_blank_passphrase);
+	/* Unlock login keys with the password. */
+	retval = unlock_at_least_one_key(pamh,pass,logindir,namelist,n,
+	                                 allow_blank_passphrase);
+	CLEANUP_AND_RETURN(retval);
 }
 
 
@@ -683,19 +781,19 @@
 	int attempt;			/* No. of attempt to contact agent */
 	const char *user;		/* username */
 
-#if HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
+#	if HAVE_PAM_STRUCT_OPTIONS || !HAVE_PAM_STD_OPTION
 	struct options options;
 	memset(&options, 0, sizeof options);
 	pam_std_option(&options, other_options, argc, argv);
 	/* Set LOG level to DEBUG if 'debug' option given to module. */
 	if (pam_test_option(&options, PAM_OPT_DEBUG, NULL)) {
-		log_init(MODULE_NAME, SYSLOG_LEVEL_DEBUG2, SYSLOG_FACILITY_AUTHPRIV, 0);
+		log_init(MODULE_NAME, SYSLOG_LEVEL_DEBUG1, SYSLOG_FACILITY_AUTHPRIV, 0);
 		debug("Session debugging.");
 	} else
 		log_init(MODULE_NAME, SYSLOG_LEVEL_ERROR, SYSLOG_FACILITY_AUTHPRIV, 0);
-#else
+#	else
 	log_init(MODULE_NAME, SYSLOG_LEVEL_ERROR, SYSLOG_FACILITY_AUTHPRIV, 0);
-#endif
+#	endif
 
 	/* dump output of ssh-agent in ~/.ssh */
 	if ((retval = pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS)
Index: libpam-ssh/pam_ssh.8
===================================================================
--- libpam-ssh.orig/pam_ssh.8	2009-04-04 10:59:20.000000000 +0200
+++ libpam-ssh/pam_ssh.8	2009-04-04 11:01:11.000000000 +0200
@@ -40,12 +40,6 @@
 .Sh NAME
 .Nm pam_ssh
 .Nd authentication and session management with SSH private keys
-.Sh SYNOPSIS
-.Op Ar service-name
-.Ar module-type
-.Ar control-flag
-.Pa pam_ssh
-.Op Ar options
 .Sh DESCRIPTION
 The
 SSH
@@ -54,22 +48,13 @@
 provides functionality for two PAM categories:
 authentication
 and session management.
-In terms of the
-.Ar module-type
-parameter, they are the
-.Dq Li auth
-and
-.Dq Li session
-features.
-It also provides null functions for the remaining categories.
 .Ss SSH Authentication Module
 The
 SSH
 authentication component
-provides a function to verify the identity of a user
-.Pq Fn pam_sm_authenticate ,
+verifies the identity of a user
 by prompting the user for a passphrase and verifying that it can
-decrypt the target user's SSH key using that passphrase.
+decrypt at least one of the user's SSH login keys using that passphrase.
 .Pp
 The following options may be passed to the authentication module:
 .Bl -tag -width ".Cm use_first_pass"
@@ -83,48 +68,51 @@
 is not the first in the stack,
 and a previous module
 obtained the user's password,
-that password is used
-to authenticate the user.
+then that password is used
+to decrypt the user's SSH login keys.
 If this fails,
-the authentication module returns failure
-without prompting the user for a password.
-This option has no effect
-if the authentication module
-is the first in the stack,
-or if no previous modules
-obtained the user's password.
+then the authentication module returns failure
+without prompting the user for a passphrase.
 .It Cm try_first_pass
-This option is similar to the
+Similar to the
 .Cm use_first_pass
 option,
-except that if the previously obtained password fails,
-the user is prompted for another password.
-.It Cm keyfiles
-Specify the comma-separated list of files in
-.Pa $HOME/.ssh
-to check for SSH keys.
-The default is
-.Dq id_dsa,id_rsa,identity .
+except that if the previously obtained password fails to decrypt
+any of the SSH login keys,
+then the user is prompted for an SSH passphrase.
+.Pp
+.Cm Cm try_first_pass
+has no effect if
+.Nm pam_ssh
+is the first module on the stack,
+or if no previous modules
+obtained the user's password.
 .El
+.Pp
+If neither
+.Cm Cm use_first_pass
+nor
+.Cm Cm try_first_pass
+is specified,
+.Nm pam_ssh
+will unconditionally ask for an SSH passphrase.
+.Pp
+In addition to the above authentication procedure, all
+standard SSH keys (identity, id_rsa, id_dsa) for which the
+obtained password matches will be decrypted.
 .Ss SSH Session Management Module
 The
 SSH
 session management component
-provides functions to initiate
-.Pq Fn pam_sm_open_session
-and terminate
-.Pq Fn pam_sm_close_session
-sessions.
-The
-.Fn pam_sm_open_session
-function starts an SSH agent,
-passing it any private keys it decrypted
+initiates sessions by starting an SSH agent,
+passing it any SSH login keys it decrypted
 during the authentication phase,
 and sets the environment variables
-the agent specifies.
-The
-.Fn pam_sm_close_session
-function kills the previously started SSH agent
+accordingly.
+.Pp
+The SSH
+session management component
+terminates the session by killing the previously started SSH agent
 by sending it a
 .Dv SIGTERM .
 .Pp
@@ -136,22 +124,34 @@
 .Dv LOG_DEBUG
 level.
 .El
+.Sh INFORMATION LEAKS
+Be careful with the using the
+.Cm Cm try_first_pass
+option when
+.Nm pam_ssh
+is the first authentication module
+because it will then leak information about existing users
+without login keys: such users will not be asked for a specific SSH
+passphrase, whereas non-existing users and existing users with
+login keys will be asked for a passphrase.
 .Sh FILES
-.Bl -tag -width ".Pa $HOME/.ssh2/id_dsa_*" -compact
+.Bl -tag -width ".Pa $HOME/.ssh/login-keys.d/" -compact
 .It Pa $HOME/.ssh/identity
-SSH1/OpenSSH RSA key
+.It Pa $HOME/.ssh/id_rsa
 .It Pa $HOME/.ssh/id_dsa
-OpenSSH DSA key
-.It Pa $HOME/.ssh2/id_rsa_*
-SSH2 RSA keys
-.It Pa $HOME/.ssh2/id_dsa_*
-SSH2 DSA keys
+OpenSSH DSA/RSA keys decrypted by pam_ssh.
+.It Pa $HOME/.ssh/login-keys.d/
+Location of (possibly symbolic links to) OpenSSH DSA/RSA keys used for
+authentication and decrypted by pam_ssh.
+.It Pa /var/log/auth.log
+Usual log file for
+.Xr syslog 3
 .El
 .Sh SEE ALSO
 .Xr ssh-agent 1 ,
 .Xr syslog 3 ,
 .Xr pam.conf 5 ,
-.Xr pam 8
+.Xr pam 8 .
 .Sh AUTHORS
 .Pp
 .An -nosplit
@@ -162,3 +162,5 @@
 wrote the original OpenPAM support code.
 .An "Mark R V Murray"
 wrote the original version of this manual page.
+.An "Jens Peter Secher"
+introduced the login-key concept.
